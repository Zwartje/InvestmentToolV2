# This ensembles all the data sourcing codes.

import pandas as pd
import pandas_datareader.data as web
from datetime import datetime
import yfinance as yf
import utils as ut


# Stock price data downloader. Generated by CHATGPT.
def download_stock_price_daily_close(code, start_date, end_date):

    try:
        # Download data for the S&P 500 index
        price = yf.download(code, start=start_date, end=end_date)

        # Select the 'Close' column from the DataFrame
        daily_close_prices = price['Close']

        return daily_close_prices
    except Exception as e:
        print("An error occurred:", e)
        return None


# US yield curve data downloader. Generated by CHATGPT.
# The main difference between the USTREASURY and DGS* series is the maturity of the Treasury securities used to calculate the yields.
# The DGS* series represents the yields on actively traded Treasury securities with specific maturities, such as 1-month, 2-year, 5-year, etc. These yields are based on the secondary market, where Treasury securities are bought and sold after they are issued. As a result, the DGS* series reflects market expectations about future interest rates, inflation, and other economic factors that affect the demand for and supply of Treasury securities.
# The USTREASURY series, on the other hand, represents the yields on Treasury securities of various maturities that are auctioned by the U.S. Treasury Department. The maturities range from 4 weeks to 30 years, and the yields are based on the prices at which the securities are sold to investors. As a result, the USTREASURY series reflects the actual borrowing costs of the U.S. government and is used as a benchmark for many financial instruments, such as mortgages and corporate bonds.
# Both series are widely used as indicators of the overall level and shape of the yield curve, which is a graph that shows the yields of Treasury securities with different maturities. However, the DGS* series tends to be more volatile and sensitive to short-term changes in market expectations, while the USTREASURY series tends to be more stable and reflects the long-term borrowing costs of the U.S. government.


def download_yield_curve_data(series_code, start_date='1962-01-02', end_date=datetime.today().strftime('%Y-%m-%d')):
    if series_code not in ['DGS', 'UST']:
        raise ValueError('series_code must be either "DGS" or "UST"')

    if series_code == 'DGS':
        series_ids = [
            'DGS1MO', 'DGS3MO', 'DGS6MO', 'DGS1', 'DGS2', 'DGS3',
            'DGS5', 'DGS7', 'DGS10', 'DGS20', 'DGS30'
        ]  # Series IDs for the yield curve data

        # Download yield curve data from FRED
        yield_curve_data = pd.DataFrame()
        for series_id in series_ids:
            data = web.DataReader(series_id, 'fred', start_date, end_date)
            yield_curve_data[series_id] = data[series_id]
    else:
        series_ids = [
            'DTB1', 'DTB3', 'DTB6', 'DGS1', 'DGS2', 'DGS3', 'DGS5',
            'DGS7', 'DGS10', 'DGS20', 'DGS30'
        ]  # Series IDs for the yield curve data

        # Download yield curve data from FRED
        yield_curve_data = pd.DataFrame()
        for series_id in series_ids:
            data = web.DataReader(f'USTREASURY/YIELD/{series_id}', 'fred', start_date, end_date)
            yield_curve_data[series_id] = data[f'USTREASURY/YIELD/{series_id}']

    return yield_curve_data


def download_fred_data(series_id, start_date='1990-01-01', end_date=datetime.today().strftime('%Y-%m-%d')):
    """
    Downloads historical data from Fred.

    Parameters:
        series_id (str): The series ID of the variable of interest.
        start_date (str): Start date of the data in the format 'YYYY-MM-DD'.
        end_date (str): End date of the data in the format 'YYYY-MM-DD'.

    Returns:
        pandas.DataFrame: A DataFrame containing the variable of interest.
    """

    # Fetch the data using pandas_datareader
    try:
        df = web.DataReader(series_id, 'fred', start_date, end_date)
        return df
    except Exception as e:
        print(f"Failed to fetch data: {e}")
        return None


class EconomicVariables:
    def __init__(self, data_df, country_code, series_id):
        self.data = data_df
        self.country_code = country_code
        self.series_id = series_id

    calculate_monthly_average = ut.calculate_monthly_average
    calculate_yoy_change = ut.calculate_yoy_change
    calculate_running_percentile = ut.calculate_running_percentile
