# This ensembles all the data sourcing and processing codes.

import pandas as pd
import pandas_datareader.data as web
from datetime import datetime
import yfinance as yf
import scipy.stats as stats
import utils as ut


# Stock price data downloader. Generated by CHATGPT.
def download_stock_price_daily_close(code, start_date, end_date):

    try:
        # Download data for the S&P 500 index
        price = yf.download(code, start=start_date, end=end_date)
        # Select the 'Close' column from the DataFrame
        daily_close_prices = price['Close']
        return daily_close_prices
    except Exception as e:
        print("An error occurred:", e)
        return None


# US yield curve data downloader. Generated by CHATGPT.
def download_yield_curve_data(series_code, start_date='1962-01-02', end_date=datetime.today().strftime('%Y-%m-%d')):
    # The main difference between the USTREASURY and DGS* series is the maturity of the Treasury securities used to calculate the yields.
    # The DGS* series represents the yields on actively traded Treasury securities with specific maturities, such as 1-month, 2-year, 5-year, etc. These yields are based on the secondary market, where Treasury securities are bought and sold after they are issued. As a result, the DGS* series reflects market expectations about future interest rates, inflation, and other economic factors that affect the demand for and supply of Treasury securities.
    # The USTREASURY series, on the other hand, represents the yields on Treasury securities of various maturities that are auctioned by the U.S. Treasury Department. The maturities range from 4 weeks to 30 years, and the yields are based on the prices at which the securities are sold to investors. As a result, the USTREASURY series reflects the actual borrowing costs of the U.S. government and is used as a benchmark for many financial instruments, such as mortgages and corporate bonds.
    # Both series are widely used as indicators of the overall level and shape of the yield curve, which is a graph that shows the yields of Treasury securities with different maturities. However, the DGS* series tends to be more volatile and sensitive to short-term changes in market expectations, while the USTREASURY series tends to be more stable and reflects the long-term borrowing costs of the U.S. government.

    if series_code not in ['DGS', 'UST']:
        raise ValueError('series_code must be either "DGS" or "UST"')

    if series_code == 'DGS':
        series_ids = [
            'DGS1MO', 'DGS3MO', 'DGS6MO', 'DGS1', 'DGS2', 'DGS3',
            'DGS5', 'DGS7', 'DGS10', 'DGS20', 'DGS30'
        ]  # Series IDs for the yield curve data

        # Download yield curve data from FRED
        yield_curve_data = pd.DataFrame()
        for series_id in series_ids:
            data = web.DataReader(series_id, 'fred', start_date, end_date)
            yield_curve_data[series_id] = data[series_id]
    else:
        series_ids = [
            'DTB1', 'DTB3', 'DTB6', 'DGS1', 'DGS2', 'DGS3', 'DGS5',
            'DGS7', 'DGS10', 'DGS20', 'DGS30'
        ]  # Series IDs for the yield curve data

        # Download yield curve data from FRED
        yield_curve_data = pd.DataFrame()
        for series_id in series_ids:
            data = web.DataReader(f'USTREASURY/YIELD/{series_id}', 'fred', start_date, end_date)
            yield_curve_data[series_id] = data[f'USTREASURY/YIELD/{series_id}']

    return yield_curve_data


def download_fred_data(series_id, start_date='1990-01-01', end_date=datetime.today().strftime('%Y-%m-%d')):
    """
    Downloads historical data from Fred.

    Parameters:
        series_id (str): The series ID of the variable of interest.
        start_date (str): Start date of the data in the format 'YYYY-MM-DD'.
        end_date (str): End date of the data in the format 'YYYY-MM-DD'.

    Returns:
        pandas.DataFrame: A DataFrame containing the variable of interest.
    """

    # Fetch the data using pandas_datareader
    try:
        df = web.DataReader(series_id, 'fred', start_date, end_date)
        return df
    except Exception as e:
        print(f"Failed to fetch data: {e}")
        return None


def identify_data_frequency(data_df):
    time_diffs = data_df.index.to_series().diff()
    average_time_diff = time_diffs.mean(skipna=True)
    frequency = round(average_time_diff.days)
    if frequency < 2: # then we identify the data as daily frequency!
        data_df_converted = calculate_monthly_average(data_df)
        time_diffs = data_df_converted.index.to_series().diff()
        average_time_diff = time_diffs.mean(skipna=True)
        frequency = round(average_time_diff.days)
    else:
        data_df_converted = data_df
    return data_df_converted, frequency


def resample_to_last_day_in_month(data_df):
    assert isinstance(data_df.index, pd.DatetimeIndex), "Index is not of datetime type"
    data_df_resampled = data_df.resample('M').last().fillna(method='ffill')
    return data_df_resampled


def calculate_percentiles(data):
    # Calculate the percentile values for each data point
    percentile_values = [stats.percentileofscore(data, x, kind='rank') for x in data]
    return percentile_values


def calculate_monthly_average(data_df):
    try:
        # Resample data to monthly frequency and calculate the mean
        monthly_average_prices = data_df.resample('M').mean()
        return monthly_average_prices
    except Exception as e:
        print("An error occurred:", e)
        return None


def calculate_yoy_change(data_df):
    """
    Calculate the year-over-year (YoY) change for the economic data.
    Parameters:
        data_df (pd.DataFrame): DataFrame containing the economic data with date as index.
    Returns:
        pd.DataFrame: DataFrame containing the YoY changes with date as index.
    """
    # Ensure the DataFrame is sorted by date
    data_df = data_df.sort_index()
    # Calculate YoY change using pandas' shift() and pct_change() methods
    data_df['YoY Change'] = data_df.iloc[:, 0].pct_change(periods=12)
    # Drop the first 12 rows since they don't have enough data for the YoY calculation
    data_df = data_df.iloc[12:]
    # Create a new DataFrame containing only the YoY Change column
    yoy_df = data_df[['YoY Change']].copy()
    return yoy_df


def calculate_running_percentile(data_df, window_size):
    """
    Calculate the running percentile rank of the current data in the past x months.

    Parameters:
        data_df (pd.DataFrame): DataFrame containing the economic data with date as index.
        window_size (int): Number of months for the rolling window.

    Returns:
        pd.DataFrame: DataFrame containing the running percentile rank values with date as index.
    """
    # Ensure the DataFrame is sorted by date
    data_df = data_df.sort_index()

    # Calculate the running percentile rank using rolling window and apply method
    def percentile_rank(x):
        return pd.Series(x).rank(pct=True).iloc[-1]
    running_percentile = data_df.rolling(window=window_size).apply(percentile_rank)
    # Drop the first window_size rows since they don't have enough data for the YoY calculation
    running_percentile = running_percentile.iloc[window_size:]
    return running_percentile


class EconomicVariables:
    def __init__(self, data_df, series_id, frequency, country_code='US', lag_period_in_months=0):
        self.data = data_df
        self.country_code = country_code
        self.series_id = series_id
        self.lag_period = lag_period_in_months
        self.frequency = frequency
        self.data_r_p = None
        self.data_yoy = None

    def generate_yoy_change(self):
        self.data_yoy = calculate_yoy_change(self.data)
        column_name = f"{self.series_id}_yoy"
        self.data_yoy.rename(columns={self.data_yoy.columns[0]: column_name}, inplace=True)

    def generate_running_percentile(self, window_size=12):
        self.data_r_p = calculate_running_percentile(self.data, window_size)
        column_name = f"{self.series_id}_rp"
        self.data_r_p.rename(columns={self.data_r_p.columns[0]: column_name}, inplace=True)



